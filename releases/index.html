<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libnabo: libnabo</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libnabo
   &#160;<span id="projectnumber">1.1.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">libnabo </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>from <a href="http://github.com/ethz-asl/libnabo">http://github.com/ethz-asl/libnabo</a> by Stéphane Magnenat (<a href="http://stephane.magnenat.net">http://stephane.magnenat.net</a>), ASL-ETHZ, Switzerland (<a href="http://www.asl.ethz.ch">http://www.asl.ethz.ch</a>)</p>
<p>libnabo is a fast K Nearest Neighbour library for low-dimensional spaces. It provides a clean, legacy-free, scalar-type–agnostic API thanks to C++ templates. Its current CPU implementation is strongly inspired by <a class="el" href="index.html#ANN">ANN</a>, but with more compact data types. On the average, libnabo is 5% to 20% faster than <a class="el" href="index.html#ANN">ANN</a>.</p>
<p>libnabo depends on <a class="el" href="index.html#Eigen">Eigen</a>, a modern C++ matrix and linear-algebra library. libnabo works with either version 2 or 3 of Eigen.</p>
<h1><a class="anchor" id="Compilation"></a>
Compilation</h1>
<p>libnabo uses <a class="el" href="index.html#CMake">CMake</a> as build system. The complete compilation process depends on the system you are using (Linux, Mac OS X or Windows). You will find a nice introductory tutorial in this you tube video: <a href="http://www.youtube.com/watch?v=CLvZTyji_Uw">http://www.youtube.com/watch?v=CLvZTyji_Uw</a>.</p>
<h2><a class="anchor" id="Prerequisites"></a>
Prerequisites</h2>
<p>If your operating system does not provide it, you must get <a class="el" href="index.html#Eigen">Eigen</a>. <a class="el" href="index.html#Eigen">Eigen</a> only needs to be downloaded and extracted.</p>
<h2><a class="anchor" id="CompilationOptions"></a>
Compilation options</h2>
<p>libnabo provides the following compilation options, available through <a class="el" href="index.html#CMake">CMake</a> :</p><ul>
<li><code>SHARED_LIBS</code> (boolean, default: <code>false</code>): if <code>true</code>, build a shared library, otherwise build a static library</li>
</ul>
<p>You specify them with a command-line tool, <code>ccmake</code>, or with a graphical tool, <code>cmake-gui</code>. Please read the <a href="http://www.cmake.org/cmake/help/cmake2.6docs.html">CMake documentation</a> for more information.</p>
<h2><a class="anchor" id="QuickCompilationUnix"></a>
Quick compilation and installation under Unix</h2>
<p>Under Unix, assuming that <a class="el" href="index.html#Eigen">Eigen</a> is installed system-wide, you can compile (with optimisation and debug information) and install libnabo in <code>/usr/local</code> with the following commands run in the top-level directory of libnabo's sources: </p><div class="fragment"><div class="line">SRC_DIR=`pwd`</div>
<div class="line">BUILD_DIR=${SRC_DIR}/build</div>
<div class="line">mkdir -p ${BUILD_DIR} &amp;&amp; cd ${BUILD_DIR}</div>
<div class="line">cmake -DCMAKE_BUILD_TYPE=RelWithDebInfo ${SRC_DIR}</div>
<div class="line"><span class="preprocessor"># if Eigen is not available system-wide, run at that point:</span></div>
<div class="line"><span class="preprocessor">#   cmake-gui .</span></div>
<div class="line"><span class="preprocessor"># cmake-gui allows you to tell the location of Eigen</span></div>
<div class="line">make</div>
<div class="line">sudo make install</div>
</div><!-- fragment --><p>These lines will compile libnabo in a <code>build</code> sub-directory and therefore keep your source tree clean. Note that you could compile libnabo anywhere you have write access, such as in <code>/tmp/libnabo</code>. This out-of-source build is a nice feature of <a class="el" href="index.html#CMake">CMake</a>. If <a class="el" href="index.html#Eigen">Eigen</a> is not installed system-wide, you might have to tell <a class="el" href="index.html#CMake">CMake</a> where to find them (using <code>ccmake</code> or <code>cmake-gui</code>).</p>
<p>You can generate the documentation by typing: </p><div class="fragment"><div class="line">make doc</div>
</div><!-- fragment --><h1><a class="anchor" id="Usage"></a>
Usage</h1>
<p>libnabo is easy to use. For example, assuming that you are working with floats and that you have a point set <code>M</code> and a query point <code>q</code>, you can find the <code>K</code> nearest neighbours of <code>q</code> in <code>M</code> :</p>
<div class="fragment"><div class="line"><span class="comment">// This example is in the public domain</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="nabo_8h.html">nabo/nabo.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">        <span class="keyword">using namespace </span><a class="code" href="namespaceNabo.html">Nabo</a>;</div>
<div class="line">        <span class="keyword">using namespace </span>Eigen;</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// 100 points in 3D</span></div>
<div class="line">        MatrixXf M = MatrixXf::Random(3, 100);</div>
<div class="line">        <span class="comment">// 1 query points</span></div>
<div class="line">        VectorXf q = VectorXf::Random(3);</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// create a kd-tree for M, note that M must stay valid during the lifetime of the kd-tree</span></div>
<div class="line">        <a class="code" href="namespaceNabo.html#a371a2be987b041b28175681451dd80ce">NNSearchF</a>* nns = <a class="code" href="structNabo_1_1NearestNeighbourSearch.html#a4de25fa75068e06b105ae4f092e99ee5">NNSearchF::createKDTreeLinearHeap</a>(M);</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// look for the 5 nearest neighbour of a the single-point query</span></div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">int</span> K = 5;</div>
<div class="line">        VectorXi indices(K);</div>
<div class="line">        VectorXf dists2(K);</div>
<div class="line">        nns-&gt;knn(q, indices, dists2, K);</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// cleanup kd-tree</span></div>
<div class="line">        <span class="keyword">delete</span> nns;</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="anabo_8h_html"><div class="ttname"><a href="nabo_8h.html">nabo.h</a></div><div class="ttdoc">public interface</div></div>
<div class="ttc" id="anamespaceNabo_html"><div class="ttname"><a href="namespaceNabo.html">Nabo</a></div><div class="ttdoc">Namespace for Nabo.</div><div class="ttdef"><b>Definition:</b> brute_force_cpu.cpp:41</div></div>
<div class="ttc" id="anamespaceNabo_html_a371a2be987b041b28175681451dd80ce"><div class="ttname"><a href="namespaceNabo.html#a371a2be987b041b28175681451dd80ce">Nabo::NNSearchF</a></div><div class="ttdeci">NearestNeighbourSearch&lt; float &gt; NNSearchF</div><div class="ttdoc">nearest neighbour search with scalars of type float</div><div class="ttdef"><b>Definition:</b> nabo.h:440</div></div>
<div class="ttc" id="astructNabo_1_1NearestNeighbourSearch_html_a4de25fa75068e06b105ae4f092e99ee5"><div class="ttname"><a href="structNabo_1_1NearestNeighbourSearch.html#a4de25fa75068e06b105ae4f092e99ee5">Nabo::NearestNeighbourSearch::createKDTreeLinearHeap</a></div><div class="ttdeci">static NearestNeighbourSearch * createKDTreeLinearHeap(const CloudType &amp;cloud, const Index dim=std::numeric_limits&lt; Index &gt;::max(), const unsigned creationOptionFlags=0, const Parameters &amp;additionalParameters=Parameters())</div><div class="ttdoc">Create a nearest-neighbour search, using a kd-tree with linear heap, good for small k (~up to 30)</div><div class="ttdef"><b>Definition:</b> nabo.cpp:166</div></div>
</div><!-- fragment --><p>In this example, <code>M</code> is an <a class="el" href="index.html#Eigen">Eigen</a> (refering to the software, not to the math) matrix (column major, float) and <code>q</code> is an <a class="el" href="index.html#Eigen">Eigen</a> vector (float). The results <code>indices</code> and <code>dists2</code> are <a class="el" href="index.html#Eigen">Eigen</a> vectors of indices and squared distances refering to the columns of <code>M</code>.</p>
<p>Here is a slightly more complex example:</p>
<div class="fragment"><div class="line"><span class="comment">// This example is in the public domain</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="nabo_8h.html">nabo/nabo.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">        <span class="keyword">using namespace </span><a class="code" href="namespaceNabo.html">Nabo</a>;</div>
<div class="line">        <span class="keyword">using namespace </span>Eigen;</div>
<div class="line">        <span class="keyword">using namespace </span>std;</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// 100 points in 3D</span></div>
<div class="line">        MatrixXf M = MatrixXf::Random(3, 100);</div>
<div class="line">        <span class="comment">// 50 query points</span></div>
<div class="line">        MatrixXf q = MatrixXf::Random(3, 50);</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// Create a kd-tree for M, note that M must stay valid during the lifetime of the kd-tree.</span></div>
<div class="line">        <a class="code" href="namespaceNabo.html#a371a2be987b041b28175681451dd80ce">NNSearchF</a>* nns = <a class="code" href="structNabo_1_1NearestNeighbourSearch.html#a4de25fa75068e06b105ae4f092e99ee5">NNSearchF::createKDTreeLinearHeap</a>(M);</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// The output of the query are a matrix of indices to columns of M and </span></div>
<div class="line">        <span class="comment">// a matrix of squared distances corresponding to these indices.</span></div>
<div class="line">        <span class="comment">// These matrix must have the correct size when passed to the search function.</span></div>
<div class="line">        MatrixXi indices;</div>
<div class="line">        MatrixXf dists2;</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// Look for the 5 nearest neighbours of each query point, </span></div>
<div class="line">        <span class="comment">// We do not want approximations but we want to sort by the distance,</span></div>
<div class="line">        indices.resize(5, q.cols());</div>
<div class="line">        dists2.resize(5, q.cols());</div>
<div class="line">        nns-&gt;knn(q, indices, dists2, 5, 0, <a class="code" href="structNabo_1_1NearestNeighbourSearch.html#a4d38e811608982919bd6760f52cd21b3a9418d7e91ac77b382ae8447aa58c6345">NNSearchF::SORT_RESULTS</a>);</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// Look for the 3 nearest neighbours of each query point, use the data themselves for the query.</span></div>
<div class="line">        <span class="comment">// We do not want approximations but we want to sort by the distance,</span></div>
<div class="line">        <span class="comment">// and we want to allow self-match.</span></div>
<div class="line">        indices.resize(3, M.cols());</div>
<div class="line">        dists2.resize(3, M.cols());</div>
<div class="line">        nns-&gt;knn(M, indices, dists2, 3, 0, <a class="code" href="structNabo_1_1NearestNeighbourSearch.html#a4d38e811608982919bd6760f52cd21b3a9418d7e91ac77b382ae8447aa58c6345">NNSearchF::SORT_RESULTS</a> | <a class="code" href="structNabo_1_1NearestNeighbourSearch.html#a4d38e811608982919bd6760f52cd21b3a37d6420b3c623f90f315425a6e697bc4">NNSearchF::ALLOW_SELF_MATCH</a>);</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// Make sure that the closest return points correspond to the points from M.</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 100; ++i)</div>
<div class="line">        {</div>
<div class="line">                <span class="comment">// The query is the data itself and we allow self-match.</span></div>
<div class="line">                <span class="keywordflow">if</span> (indices.coeff(0, i) != i)</div>
<div class="line">                        cerr &lt;&lt; <span class="stringliteral">&quot;Oups, something went wrong: &quot;</span> &lt;&lt; indices.coeff(0, i) &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt;  i &lt;&lt; endl;</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// Now look for the 2 nearset neighbours of each query point.</span></div>
<div class="line">        <span class="comment">// We do allow 10% approximation but do not want to allow self-match.</span></div>
<div class="line">        <span class="comment">// We do not care about sorting either.</span></div>
<div class="line">        indices.resize(2, M.cols());</div>
<div class="line">        dists2.resize(2, M.cols());</div>
<div class="line">        nns-&gt;knn(M, indices, dists2, 2, 0.1, 0);</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 50; ++i)</div>
<div class="line">        {</div>
<div class="line">                <span class="comment">// The query is the data itself but we forbide self-match.</span></div>
<div class="line">                <span class="keywordflow">if</span> (indices.coeff(0, i) == i)</div>
<div class="line">                        cerr &lt;&lt; <span class="stringliteral">&quot;Oups, something went wrong: &quot;</span> &lt;&lt; indices.coeff(0, i) &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt;  i &lt;&lt; endl;</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// Cleanup the kd-tree.</span></div>
<div class="line">        <span class="keyword">delete</span> nns;</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="astructNabo_1_1NearestNeighbourSearch_html_a4d38e811608982919bd6760f52cd21b3a37d6420b3c623f90f315425a6e697bc4"><div class="ttname"><a href="structNabo_1_1NearestNeighbourSearch.html#a4d38e811608982919bd6760f52cd21b3a37d6420b3c623f90f315425a6e697bc4">Nabo::NearestNeighbourSearch::ALLOW_SELF_MATCH</a></div><div class="ttdeci">@ ALLOW_SELF_MATCH</div><div class="ttdoc">allows the return of the same point as the query, if this point is in the data cloud; forbidden by de...</div><div class="ttdef"><b>Definition:</b> nabo.h:304</div></div>
<div class="ttc" id="astructNabo_1_1NearestNeighbourSearch_html_a4d38e811608982919bd6760f52cd21b3a9418d7e91ac77b382ae8447aa58c6345"><div class="ttname"><a href="structNabo_1_1NearestNeighbourSearch.html#a4d38e811608982919bd6760f52cd21b3a9418d7e91ac77b382ae8447aa58c6345">Nabo::NearestNeighbourSearch::SORT_RESULTS</a></div><div class="ttdeci">@ SORT_RESULTS</div><div class="ttdoc">sort points by distances, when k &gt; 1; do not sort by default</div><div class="ttdef"><b>Definition:</b> nabo.h:305</div></div>
</div><!-- fragment --><p>Note that the matrix-based interface for query is more efficient than the vector-based one, because some sanity checks can be done only once. Therefore, if you have multiple points to query, we warmly suggest to pass them as a matrix instead of calling <code>knn()</code> multiple times.</p>
<h1><a class="anchor" id="ConstructionParameters"></a>
Construction parameters</h1>
<p>The following additional construction parameters are available in KDTREE_ algorithms:</p><ul>
<li><code>bucketSize</code> (<code>unsigned</code>): bucket size, defaults to 8</li>
</ul>
<h1><a class="anchor" id="UnitTesting"></a>
Unit testing</h1>
<p>The distribution of libnabo integrates a unit test module, based on CTest. Just type:</p>
<div class="fragment"><div class="line">make test</div>
</div><!-- fragment --><p>...in the build directory to run the tests. Their outputs are available in the <code>Testing</code> directory. These consist of validation and benchmarking tests. If <a class="el" href="index.html#ANN">ANN</a> is detected when compiling libnabo, <code>make</code> <code>test</code> will also perform comparative benchmarks.</p>
<h1><a class="anchor" id="Citing"></a>
Citing libnabo</h1>
<p>If you use libnabo in the academic context, please cite this paper that evaluates its performances in the contex of ICP: </p><div class="fragment"><div class="line">@article{elsebergcomparison,</div>
<div class="line">        title={Comparison of nearest-neighbor-search strategies and implementations <span class="keywordflow">for</span> efficient shape registration},</div>
<div class="line">        author={Elseberg, J. and Magnenat, S. and Siegwart, R. and N{\<span class="stringliteral">&quot;u}chter, A.},</span></div>
<div class="line"><span class="stringliteral">        journal={Journal of Software Engineering for Robotics (JOSER)},</span></div>
<div class="line"><span class="stringliteral">        pages={2--12},</span></div>
<div class="line"><span class="stringliteral">        volume={3},</span></div>
<div class="line"><span class="stringliteral">        number={1},</span></div>
<div class="line"><span class="stringliteral">        year={2012},</span></div>
<div class="line"><span class="stringliteral">        issn={2035-3928}</span></div>
<div class="line"><span class="stringliteral">}</span></div>
</div><!-- fragment --><h1><a class="anchor" id="BugReporting"></a>
Bug reporting</h1>
<p>Please use <a href="http://github.com/ethz-asl/libnabo/issues">github's issue tracker</a> to report bugs.</p>
<h1><a class="anchor" id="License"></a>
License</h1>
<p>libnabo is released under a permissive BSD license.</p>
<h1><a class="anchor" id="Faq"></a>
Faq</h1>
<h2><a class="anchor" id="ANN"></a>
ANN</h2>
<p>libnabo differs from <a class="el" href="index.html#ANN">ANN</a> on the following points:</p>
<p>API</p><ul>
<li>templates for scalar type</li>
<li>self-match option as execution-time (instead of compile-time) parameter</li>
<li>range search instead of radius search</li>
<li><a class="el" href="index.html#Eigen">Eigen</a> library for vector and matrixes</li>
<li><p class="startli">reentrant</p>
<p class="startli">limitations</p>
</li>
<li>only euclidean distance</li>
<li>only KD-tree, no BD-tree</li>
<li><p class="startli">only ANN_KD_SL_MIDPT splitting rules</p>
<p class="startli">implementation</p>
</li>
<li>optional O(log(n)) tree heap instead of O(n) vector heap</li>
<li>compact memory representation, one memory allocation for all nodes, 5-fold smaller memory footprint compared than ANN</li>
<li>implicit reference to left child (always next node in array)</li>
<li><p class="startli">do not store bounds in nodes (that is, I do it like in ANN's article instead of like in ANN's source code)</p>
<p class="startli">performances</p>
</li>
<li>about 5% to 20% faster than ANN (both -O3 -NDEBUG), probably due to the smaller memory footprint</li>
<li>clearly memory-bound, neither OpenMP nor std::thread improve performances</li>
</ul>
<h1><a class="anchor" id="References"></a>
References</h1>
<ul>
<li><a class="anchor" id="Eigen"></a>Eigen: <a href="http://eigen.tuxfamily.org">http://eigen.tuxfamily.org</a> </li>
<li><a class="anchor" id="ANN"></a>ANN: <a href="http://www.cs.umd.edu/~mount/ANN">http://www.cs.umd.edu/~mount/ANN</a> </li>
<li><a class="anchor" id="CMake"></a>CMake: <a href="http://www.cmake.org">http://www.cmake.org</a> </li>
</ul>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
